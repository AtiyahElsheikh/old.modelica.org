             DSblock: A neutral description of dynamic systems

                              Version 3.3
                  
                                  by 

                              Martin Otter



                      Oberpfaffenhofen, April 1994

                Institute for Robotics and System Dynamics
                         DLR Oberpfaffenhofen
                           D-82230 Wessling
                          Martin.Otter@dlr.de


 Computer-Aided Control System Design (CACSD) packages should be OPEN for 
 (nonlinear) model and data import as well as export. In the following a
 low-level subroutine interface is proposed to define parameterized, 
 event-driven, explizit ordinary differential equations or differential
 algebraic equations in form of input-output "blocks". A model which is 
 described according to this interface definition is called DSblock
 (Dynamic System block). A DSblock may serve as neutral "model bus" to
 exchange nonlinear models between different modelling and simulation
 environments. The DSblock interface is designed to be able to describe models
 of multibody programs like SIMPACK, NEWEUL, DADS, electric circuits programs
 like SPICE or general purpose simulation programs like ACSL.


__
CHAPTER
DSBLOCK, Neutral interface to describe a Dynamic System block (= DSblock)
Chapter purpose:
  This is version 3.3 of the DSblock interface definition.

  A DSblock (= Dynamic System block) describes an input-output "block"
  of a general nonlinear dynamic system in a neutral way. DSblocks are
  mathematically described by explicit ordinary differential equations (ODE),
  differential-algebraic equations (DAE) or higher index differential-
  algebraic equations (HDAE). Furthermore a general event handling mechanism
  allows the treatment of discontinuous equations or equations with varying
  structure. DSblocks can be used in analysis and design methods, which use
  nonlinear time simulation as a basis, e.g. parameter variation, parameter
  optimization, trajectory optimization. A DSblock can be utilized in every
  simulation environment, which supports the calling of user-defined 
  FORTRAN or C subroutines.

  A DSblock
 
                     parameters |     | initial
                                |     | conditions
                                v     v
                              I---------I
                   U(T) ----->I DSblock I-----> Y(T)
                              I---------I
                                 ^   .
                                 |   .
                                 |   .........> W(T), X(T), Z(T)
                                 |
                                 | data from file or database

  consists of

  - Internal signals X(T), i.e. state (ODE) or descriptor variables (DAE/HDAE).
  - Input signals U(T).
  - Output signals Y(T). 
  - Indicator signals Z(T). The zero crossing of indicator signals define
    the occurrence of state events, at which the structure of the system
    may change.
  - Auxiliary signals W(T), i.e. "interesting" internal signals not to be used
    in a connection of DSblocks. Signals W are just stored at communication
    points.
  - Double precision, integer and logical parameters DP, IP and LP
    (system constants).
  - Additional data on a file or on a database to characterize a specific
    model of a DSblock.
  - A mathematical description to compute both internal signals and output
    signals from input signals, parameters, and initial conditions of the
    internal signals. The description may depend on time-, state- or
    step events, i.e. a dynamic system can be of a variable structure.
    (A time  event is defined by a predefined time instant.
     A state event is defined by the zero crossing of an indicator signal Z.
     A step  event is defined by any condition, which is checked after a 
                   completed internal step of the integrator)

  A DSblock is defined by a set of FORTRAN or C subroutines which have
  predefined interfaces, but arbitrary (used-defined) names. An overview of
  the DSblock subroutines is given below (see Chapter structure). For a
  problem at hand these subroutines can be realized either by hand, by
  preprocessors or by interface routines.
  The following preprocessors/interface routines are available:

    Preprocessors:
      ACSL    -> DSBLOCK (ANDECS-CoSyLa):
                          Generates a DSblock from a model of the general 
                          purpose simulation language ACSL, Level 10, of
                          Mitchell and Gauthier, Associates. 
      DYMOLA  -> DSBLOCK: Generates a DSblock from a model of the object
                          oriented modelling language DYMOLA of Elmqvist,
                          distributed by DynaSim AB, Sweden.
 
    Predefined DSblocks:
      ASIMPACK           (SIMPACK <--> DSBLOCK):
                          DSblock ASIMPACK is an interface to the numerical
                          general purpose multibody program SIMPACK of MAN/DLR.
      LS                 (Linear Systems <--> DSBLOCK):
                          DSblock LS is a predefined DSBLOCK for linear
                          systems of ANDECS.


  The following documentation just contains the description of the 
  FORTRAN interfaces. The C-interfaces are directly derived from the
  FORTRAN interfaces in such a way that no compatibility problems
  occur (e.g. C-DSblock called from a FORTRAN simulation environment or
  FORTRAN DSblock called from a C simulation environment). The C-interfaces
  are derived from the FORTRAN interfaces by the following simple rules:

  1. Every argument of the DSblock interface routines is a C-pointer,
     pointing on the C-type, which is equivalent to the DSblock Fortran-type.
     This has to be done, because the Fortran argument passing mechanism is
     "call by reference". Since only numeric types are included in the 
     interface routines, no problems appear (CHARACTER data types would be
     machine dependent).

  2. C-equivalents of the DSblock Fortran utility routines have to be provided
     (these procedures are called from the DSblock procedures, e.g. to
     define the names of signals). A Fortran utility routine "BLOXXX" has 
     an equivalent C-procedure "cbloxxx". The arguments are the same,
     however for the C-procedure the usual C-types are used. Example:
          Fortran:    CALL BLO3PD ('MLOAD', 'mass of load in [kg]')
          C      :        cblo3pd ("mload", "mass of load in [kg]");


  The following mathematical description forms of DSblocks are supported:
 
  1. Explicit ordinary differential equations (ODE):
 
      XD(T) = F (T, X(T),        U(T), P), X(T0) = X0
      Y (T) = G (T, X(T), XD(T), U(T), P)
      Z (T) = H (T, X(T),        U(T), P)
 
  2. Differential algebraic equations (DAE):
 
        0   = F (T, X(T), XD(T), U(T), P),  X(T0)=X0, XD(T0)=XD0,
                                            F(T0,X0,XD0,U0,P)=0
       Y(T) = G (T, X(T), XD(T), U(T), P)
       Z(T) = H (T, X(T),        U(T), P)

     Equation F must have a DAE-index of 0 or 1, i.e. it must be possible
     to solve F and dF/dT (locally) for XD = XD(T,X,U,P).
 
  3. Higher index semi-explicit differential algebraic equations (HDAE):
 
     dX_1/dT = F_1 (T, X_1(T), X_2(T), X_3(T), U(T), P)
          0  = F_2 (T, X_1(T), X_2(T), X_3(T), U(T), P)
          0  = F_3 (T, X_1(T), X_2(T), X_3(T), U(T), P)
          0  = F_4 (T, X_1(T),                 U(T), P)
          0  = F_5 (T, X_1(T),                 U(T), P)
               X = < X_1' X_2' X_3' >' 
               dF_2/dX_2 is regular (X_2 is an index-1 variable)
               dF_3/dX_3 is regular and F_3 = dF_4/dt
                   (X_3 is an index-2 variable)
               F_5 is an integral invariant of F_1,F_2,F_3 (or F_1,F_2,F_4)
                   and can be used for numerical stabilization. That is every
                   EXACT solution of the first 3 equations, fulfils the last
                   equation.
               At the initial time T0 all 5 equations must be fulfilled.
       Y (T) = G  (T, X(T), XD(T), U(T), P)
       Z (T) = H  (T, X(T),        U(T), P)

  where
         T   = independent variable (time),
         T0  = initial value of independent variable (time),
         X   = state vector (ODE), descriptor variables (DAE,HDAE),
         X0  = initial value of X,
         XD  = first derivative of X (= dX/dT),
         XD0 = initial value of XD (only used for DAEs),
         U   = input signals,
         Y   = output signals,
         Z   = indicator signals (their zeros define the occurrence of state
               events, at which the structure of the system may change),
         P   = double precision, integer or logical parameters
               (= system constants)


  Multibody systems are an important application of HDAEs. Here:

     F_1: Dynamic equation
     F_2: Friction equation, if friction force depends on constraint force
     F_3: Equations of constrained on acceleration level
     F_4: Equations of constrained on velocity level
     F_5: Equations of constrained on position level (i.e. F_4 = dF_5/dT)

  There are integrators available to solve higher index DAEs as in item 3. E.g.:

  Multi-step integrator ODASSL of Fuehrer (based on DASSL of Petzold) has
  5 options to solve a HDAE (here it is assumed, that F_5 is an index 3
  condition):
                                         using
    as                   index-1 DAE:    F_1, F_2, F_3
    as partly stabilized index-1 DAE:    F_1, F_2, F_3, F_4
    as full   stabilized index-1 DAE:    F_1, F_2, F_3, F_4, F_5
    as                   index-2 DAE:    F_1, F_2,      F_4
    as        stabilized index-2 DAE:    F_1, F_2,      F_4, F_5

  Extrapolation integrator RPDAE1 (MEXX-variant of Lubich) can solve a HDAE
  in 2 different ways, if x_2,f_2 are not present:

    as                   index-2 DAE:    F_1,           F_4
    as        stabilized index-2 DAE:    F_1,           F_4, F_5

  Note: Even if an integrator does not use all equations (e.g. if solved as
        index-2 DAE), ALL equations have to be fullfilled at the initial time.
 
Chapter structure:
  Procedures:
    BLOCKB  : Define a new model of a DSblock
              (BLOCKB must always be provided. The other subroutines must
              only be provided, if needed).
    BLOCKC  : Close a model of a DSblock (close files, free storage).
    BLOCKF  : Compute derivative of state vector (ODE) or residual (DAE,HDAE).
    BLOCKG  : Compute output signals.
    BLOCKH  : Compute indicator signals.
    BLOCKJ  : Compute Jacobian matrix.
    BLOCKK  : To be called at every communication point.
    BLOCKP  : Check parameter set (DP,IP,LP).
    BLOCKS  : To be called before integration starts (initial section).
    BLOCKT  : To be called after integration terminated (terminal section).
    BLOCKV  : To be called after a time-, state- or step-event occured
              (discrete section).
  Chapters:
    UTILITY : Utility subroutines to implement DSblocks

Chapter parameters:
  none
 
Chapter database structure:
  none

Remarks:
  - No specific calling sequence of the DSblock subroutines BLOCKF, BLOCKG,
    BLOCKH, BLOCKJ or BLOCKK can be assumed. For example, it cannot be
    guaranteed that subroutine BLOCKF is always called before subroutine
    BLOCKG. In fact, BLOCKF and BLOCKG will usually be called at different
    time instants when using a dense output integrator. However, if not 
    using a dense output integrator, the two DSblock subroutines will always
    be called in the order BLOCKF, BLOCKG at communication points.
    To avoid unnecessary computations of auxiliary variables, which are needed
    in several of the mentioned subroutines, argument ICALL is provided.

  - ICALL is used as first argument in subroutines BLOCKF, BLOCKG, BLOCKH,
    BLOCKJ, BLOCKK and BLOCKV. Usually ICALL can be ignored. ICALL is set
    to 0, if one of the input arguments of these subroutines, i.e. T, X(T),
    XD(T), U(T), is changed. ICALL can be used to avoid multiple computation
    of auxiliary variables needed in more than one BLOCKx subroutine. Example:
               SUBROUTINE BLOCKx (ICALL, ...)
                  -- declarations
               IF ( ICALL.EQ.0 ) THEN
                  ICALL = 1
                  -- compute auxiliary variables and store them
                  -- in the user work arrays DUSER, IUSER or LUSER
               ENDIF
 
Literature:
  N. Gaus, M. Otter: Dynamic Simulation in Concurrent Control Engineering.
                     In "5th IFAC/IMACS Symposium on Computer Aided
                     Design in Control Systems", Swansea, UK, July 1991,
                     Preprints pp. 123-126.
 
Example:
  none
******
_utility__
CHAPTER
UTILITY, Utility subroutines to implement DSblocks
Chapter purpose:
  In this chapter utility subroutines are provided, to implement 
  DSblock-subroutines. Usually the subroutines in this chapter can
  only be called in special circumstances (e.g. only in BLOCKB-subroutine
  if option parameter IOPT=2).

  In principal every valid FORTRAN statement is allowed in the
  DSblock-subroutines. However, it should be noted, that a DSblock will be
  called in different simulation environments. To allow a "good" software
  integration in such an environment the following FORTRAN statements should
  NOT be used:

         READ (from standard input), WRITE or PRINT (on standard output),
         STOP or PAUSE

  Furthermore it is dangerous to use a specific logical unit number for
  file handling, since the simulation environment or other DSblocks may
  use the same unit number as well.

  Instead one of the following utility subroutines should be utilized:
    BLOPRI        to print a text line on standard output
    BLOERL/BLOERS to print an error or warning message on standard output
    BLOLUB/BLOLUC to inquire a permitted logical unit number and to 
                  return it back, if it is no longer needed 
    BLO2MF        to inquire the name of the file, on which additional
                  data of a model resides.

  For every simulation environment customized realizations of the
  utility subroutines are provided.
  
Chapter structure:
  Procedures:
    Can be called in every DSblock subroutine:
      BLOERL:  Print error/warning message
      BLOERS:  Print error/warning message including run time values
      BLOPRI:  Write a text line on standard output
      BLOLUB:  Inquire a logical unit number
      BLOLUC:  Return a logical unit number back 
      BLOSID:  Inquire values, which have been set in the simulation
               environment (e.g. "event-epsilon").

    Can only be called in BLOCKB, if IOPT=1:
      BLO1DT:  Set description text and version number for a DSblock
      BLO1HT:  Define name of file, the help text for a DSblock is to be found

    Can only be called in BLOCKB, if IOPT=2:
      BLO2DT:  Set description text and version number for a model of a 
               DSblock
      BLO2HT:  Define name of file, the help text for a specific model of
               a DSblock is to be found
      BLO2MF:  Inquire name of file on which additional data of a model
               of a DSblock is stored

    Can only be called in BLOCKB, if IOPT=3:
      BLO3DD:  Redefine default values of the simulation environment
      BLO3DE:  (e.g. final simulation time, tolerances).
      BLO3DI:

      BLO3MD:  Define minimum and maximum values of parameters.
      BLO3MI:

      BLO3PD:  Define names, types and description texts of parameters.
      BLO3PI:  Parameters can be scalars (BLO3Px) or arrays (BLO3Rx) of 
      BLO3PL:  type Double precision, Integer or Logical.
      BLO3RD:
      BLO3RI:
      BLO3RL:
 
      BLO3SU:  Define names, types and description texts of signals
      BLO3SW:  U, W, X, Y or Z.
      BLO3SX:  Signals can be scalars (BLO3Sx) or arrays (BLO3Tx)
      BLO3SY:
      BLO3SZ:
      BLO3TU:
      BLO3TW:
      BLO3TX:
      BLO3TY:
      BLO3TZ:

      BLO3UX:  Define the elements of the output equations which explicitly
               depend on input signals U or/and on the derivative of the
               state vector XD

  Chapters:
    ANDECS  :  Utility subroutines for DSblocks, which can only be used in
               an ANDECS environment (e.g. read object from database)

Chapter parameters:
  none
 
Chapter database structure:
  none
 
Literature:
  none
 
Example:
  none
******
_blockb__
SUBROUTINE
BLOCKB, Define a new model of a DSblock
Procedure purpose:
  By this subroutine, the signals, parameters, and internal user-defined data
  structures of a new model of a DSblock are defined and initialized.
 
  For programming convenience a DOUBLE PRECISION-, INTEGER- and LOGICAL
  work array are provided which are left unmodified by the calling routines.
  They may be used to exchange data between the DSblock subroutines.

Usage:
  CALL BLOCKB (IOPT,INFO,SIG,DIM,T0,X0,XD0,DP,IP,LP,DUSER,IUSER,LUSER,IERR)
 
  IOPT  :  IN, INTEGER
           Option parameter. The subroutine is called first with iopt=1 to
           inquire information about the DSblock. Then, for every new model
           the subroutine is called first with iopt=2 to inquire dimension
           information. According to the dimension information, storage is
           dynamically allocated by the calling subroutine. Finally, the
           subroutine is called with iopt=3 to initialize the model
           (e.g. to initialize the allocated storage).
           = 1: Define properties of the DSblock.
           = 2: Define dimensions of a new model of the DSblock.
           = 3: Initialize model.
  INFO  :  IN, OUT, INTEGER(2)
  SIG   :  IN, OUT, INTEGER(*)
  DIM   :  IN, OUT, INTEGER(*)
  T0    :  IN, OUT, DOUBLE
  X0    :  IN, OUT, DOUBLE(*)
  XD0   :  IN, OUT, DOUBLE(*)
  DP    :  IN, OUT, DOUBLE(*)
  IP    :  IN, OUT, INTEGER(*)
  LP    :  IN, OUT, LOGICAL(*)
  DUSER :  OUT, DOUBLE(*)
  IUSER :  OUT, INTEGER(*)
  LUSER :  OUT, LOGICAL(*)
  IERR  :  IN, OUT, INTEGER
           Error parameter
           On entry  IERR =  0 for programming convenience.
           On return IERR =  0: No error occured.
                          else: Terminate integration, since an error occured.
                                The subroutine has printed an error message.

  If IOPT = 1 then
    INFO : IN, OUT, INTEGER(2)
           On entry  INFO(1) = 0, for programming convenience.
           On return INFO(1) = 0: Only one model of the DSblock can be present
                                  at the same time. This is the case if BLOCKx
                                  have a STATIC rather than a dynamic internal
                                  data structure for a model.
                             = 1: Several models of the DSblock can be present
                                  at the same time.

  elseif IOPT = 2 then
    INFO : IN, OUT, INTEGER(3)
           On entry  INFO(1)/(2) = 0 for programming convenience.   
           On return INFO(1) = 0: model is an ODE
                             = 1: model is a DAE
                             = 2: model is a HDAE
                     INFO(2) = 0: No STEP events can occur.
                             = 1: STEP events can occur (= subroutine BLOCKF is
                                  called after every successful step of the 
                                  integrator. If a specified condition holds,
                                  an event occurs, i.e. the integration is
                                  halted)
                     INFO(3) = 0: Jacobian must be calculated numerically
                                  (subroutine blockJ is a dummy routine).
                             = 1: Subroutine blockJ calculates the Jacobian
                                  analytically.
    SIG  : IN, OUT, INTEGER(*)
           Number of signals and parameters. A signal or a parameter can be
           a scalar or an array with upto 6 dimensions. The names and 
           dimensions of signals and parameters are defined by subroutines
           BLO3Px, BLO3Rx, BLO3Sx or BLO3Tx. The actual values of signals
           and parameters are mapped on vectors. The dimensions of these
           vectors are given via argument DIM.
	   On entry SIG(i)=0, for programming convenience.
	   On return
           SIG(1) >= 0: NXSIG (number of X-signals , see BLO3SX/BLO3TX)
           SIG(2) >= 0: NUSIG (number of U-signals , see BLO3SU/BLO3TU)
           SIG(3) >= 0: NYSIG (number of Y-signals , see BLO3SY/BLO3TY)
           SIG(4) >= 0: NZSIG (number of Z-signals , see BLO3SZ/BLO3TZ)
           SIG(5) >= 0: NWSIG (number of W-signals , see BLO3SW/BLO3TW)
           SIG(6) >= 0: NPSIG (number of parameters, see BLO3Px/BLO3Rx)
    DIM  : IN, OUT, INTEGER(*)
	   Dimensions of the signal and parameter vectors
           On entry DIM(i)=0, for programming convenience.
           On return
           DIM( 1) >= 0: NX  (dimension of X;
                               for systems with varying structure
                               NX is the maximum number of elements of X.
                               For HDAE's NX = NX_1 + NX_2 + NX_3)
           DIM( 2) >= 0: NU  (dimension of U).
           DIM( 3) >= 0: NY  (dimension of Y).
           DIM( 4) >= 0: NZ  (dimension of Z;
                               for systems with varying structure
                               NZ is the maximum number of elements of Z)
           DIM( 5) >= 0: NW  (dimension of auxiliary signals, see BLOCKK).

           DIM( 6) >= 0: NDP (dimension of double precision parameter 
                               vector DP).
           DIM( 7) >= 0: NIP (dimension of integer parameter vector IP).
           DIM( 8) >= 0: NLP (dimension of logical parameter vector LP).

           DIM( 9) >= 0: NDU (dimension of double precision user work array).
           DIM(10) >= 0: NIU (dimension of integer user work array).
           DIM(11) >= 0: NLU (dimension of logical user work array).

           DIM(12) >= 0: NF1 (dimension of F_1 for HDAE or dummy argument).
           DIM(13) >= 0: NF2 (dimension of F_2 for HDAE or dummy argument).
           DIM(14) >= 0: NF3 (dimension of F_3 for HDAE or dummy argument).
           DIM(15) >= 0: NF4 (dimension of F_4 for HDAE or dummy argument).
           DIM(16) >= 0: NF5 (dimension of F_5 for HDAE or dummy argument).

  elseif IOPT = 3 then
    T0   : IN, OUT, DOUBLE
           Default value for initial time.
           On entry  T0 = 0.0D0 for programming convenience.
           On return T0 can be given a new value.
    X0   : IN, OUT, DOUBLE(*)
           Default vector for initial conditions of X(T0).
           On entry  X0(i) = 0.0D0, for programming convenience.
           On return X0(i) can be given new values.
    XD0  : IN, OUT, DOUBLE(*)
           if DAE then
              Default vector for initial conditions of XD(T0).
              On entry  XD0(i) = 0.0D0, for programming convenience.
              On return XD0(i) can be given new values.
           else
              dummy argument
           endif
    DP   : IN, OUT, DOUBLE(*)
	   Default vector for double precision parameters.
           On entry  DP(i) = 0.0D0, for programming convenience.
           On return DP(i) can be given new values.
    IP   : IN, OUT, INTEGER(*)
	   Default vector for integer parameters.
           On entry  IP(i) = 0, for programming convenience.
           On return IP(i) can be given new values.
    LP   : IN, OUT, LOGICAL(*)
	   Default vector for logical parameters.
           On entry  LP(i) = .FALSE., for programming convenience.
           On return LP(i) can be given new values.
    DUSER: OUT, DOUBLE(*)
           Double precision user work array.
           Each model of a DSblock has its own work array.
    IUSER: OUT, INTEGER(*)
           Integer user work array.
           Each model of a DSblock has its own work array.
    LUSER: OUT, LOGICAL(*)
           Integer user work array.
           Each model of a DSblock has its own work array.
  endif
 
Database structure:
  user-defined
 
File input/output:
  user-defined
 
Dialog:
  user-defined
 
Method:
  user-defined
 
Remarks:
  none

Life cycle:
  1990 FEB  N. Gaus, M. Otter, DLR FF-DF: modified
            NLSIM from D. Joos, DLR FF-DF, used as basis.
  1990 JUN  N. Gaus, M. Otter, DLR FF-DF: modified
  1990 OCT  N. Gaus, M. Otter, DLR FF-DF: modified
            Definition of INFO-vector changed, NAUX added.
  1991 JUN  M. Otter, DLR FF-DF         : modified
            INFO(15) added.
  1992 FEB  M. Otter, DLR FF-DF         : modified
            Arguments SNAME, CINFO, DTEXT, PNAME, PTYP, DPDEF, IPDEF are
            removed. If needed the information of these arguments can be
            provided by a call of a subroutine of chapter DSBLOCK_UTILITY.
            Argument INFO splitted in two arguments (INFO, DIM).
            Dimension information in DIM rearranged. New argument T0.
  1992 MAR  M. Otter, DLR FF-DF         : modified
            DIM(6) (= number of parameters) removed. DIM(7)..DIM(17)
            shifted to DIM(6)..DIM(16)
  1992 MAR  M. Otter, DLR FF-DF         : modified
            Arguments SIG, DP, IP, LP introduced.
  1994 APR  M. Otter, DLR FF-DF         : modified
            INFO(3) for IOPT=2 introduced.
 
Libraries required:
  user-defined
 
Example:
  none
******
_blockc__
SUBROUTINE
BLOCKC, Close model of a DSblock
Procedure purpose:
  Subroutine BLOCKC is called, after the model of a DSblock is no longer
  needed. In BLOCKC the following actions should be programmed:

  -  if a file is open, it has to be closed.

  -  if storage was dynamically allocated, is has to be deallocated (freed).

  If no file has to be closed and no storage was allocated, this subroutine
  needs not to be provided.
 
Usage:
  CALL BLOCKC (IOPT, DUSER, IUSER, LUSER, IERR)
 
  IOPT  :  IN, INTEGER
           IOPT = 2: BLOCKB was already called with IOPT=2
                     (but not with IOPT=3).
                = 3: BLOCKB was already called with IOPT=3.
  DUSER :  IN, OUT, DOUBLE(*)
           Double precision user work array.
  IUSER :  IN, OUT, INTEGER(*)
           Integer user work array.
  LUSER :  IN, OUT, LOGICAL(*)
           Logical user work array.
  IERR  :  IN, OUT, INTEGER
           Error parameter
           On entry  IERR =  0 for programming convenience.
           On return IERR =  0: No error occured.
                          else: Terminate integration, since an error occured.
                                The subroutine has printed an error message.
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  user-defined
 
Remarks:
  - Argument IOPT is provided to handle a special case:
    In subroutine BLOCKB storage can be allocated or files can be
    opened if BLOCKB is called with IOPT=2 OR with IOPT=3 (this depends on
    the specific model). If BLOCKB was called with IOPT=2 and the
    simulation environment determines, that it cannot use the model, the
    model must be closed by subroutine BLOCKC. However, in this case BLOCKC
    must know, whether BLOCKB was already called with IOPT=2 or IOPT=3.
 
Life cycle:
  1990 FEB  N. Gaus, M. Otter, DLR FF-DF: specified
  1992 FEB  M. Otter, DLR FF-DF         : modified
            arguments IOPT and LUSER added
 
Libraries required:
  user-defined
 
Example:
  none
******
_blockf__
SUBROUTINE
BLOCKF, Compute right hand side
Procedure purpose:
  In BLOCKF the user has to program
 
  - for ODEs the right hand sides F of the differential equations
 
       dX/dT = F ( T, X(T), U(T), DP, IP, LP )
 
  - for DAEs the residual F of the differential algebraic equations
 
           0 = F ( T, X(T), XD(T), U(T), DP, IP, LP )
 
  - for HDAEs the right hand sides F_1, F_2, F_3, F_4, F_5 

     dX_1/dT = F_1 (T, X_1(T), X_2(T), X_3(T), U(T), DP, IP, LP)
         0   = F_2 (T, X_1(T), X_2(T), X_3(T), U(T), DP, IP, LP) 
         0   = F_3 (T, X_1(T), X_2(T), X_3(T), U(T), DP, IP, LP) 
         0   = F_4 (T, X_1(T),                 U(T), DP, IP, LP) 
         0   = F_5 (T, X_1(T),                 U(T), DP, IP, LP) 

    where
       X = < X_1' X_2' X_3' >'
       dF_2/dX_2 is regular (F_2 is an index-1 condition)
       dF_3/dX_3 is regular (F_3 is an index-2 condition)
       F_3 = dF_4/dT
       F_5 is an integral invariant of F_1, F_2, F_3 and can be used for
           numerical stabilization. That is every EXACT solution of the
           first 3 equations, fulfils the last equation.
 
  If the dimension of vector X is 0, subroutine BLOCKF has not to be provided.
  If it is provided, it is not called.
 
Usage:
  CALL BLOCKF (ICALL, T, X, XD, U, DP, IP, LP, F, DUSER, IUSER, LUSER, IERR)
 
  ICALL :  IN, OUT, INTEGER(*)
           ICALL is used for special applications. See "Remarks" below.
  T     :  IN, DOUBLE
           Simulation time instant.
  X     :  IN, DOUBLE(*)
           Vector X at time T.
  XD    :  IN, DOUBLE(*)
           ODE : dummy argument
           DAE : first derivative of X at time T.
           HDAE: dummy argument
  U     :  IN, DOUBLE(*)
           Input signals U at time T.
  DP    :  IN, DOUBLE(*)
           Double precision parameters.
  IP    :  IN, INTEGER(*)
           Integer parameters.
  LP    :  IN, LOGICAL(*)
           Logical parameters.
  F     :  OUT, DOUBLE(*)
           ODE : Right hand side F(1), ..., F(NX).
           DAE : Residual F(1), ..., F(NX)
           HDAE: F_1(1..), F_2(1..), F_3(1..), F_4(1..), F_5(1..).
                 If only part of F must be calculated according to ICALL,
                 only the corresponding part of F must have a value. 
  DUSER :  IN, OUT, DOUBLE(*)
           Double precision user work array.
  IUSER :  IN, OUT, INTEGER(*)
           Integer user work array.
  LUSER :  IN, OUT, LOGICAL(*)
           Logical user work array.
  IERR  :  IN, OUT, INTEGER
           Error parameter
           On entry  IERR =  0 for programming convenience.
           On return IERR =  0: No error occured.
                          else: Terminate integration, since an error occured.
                                The subroutine has printed an error message.
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  user-defined
 
Remarks:
  - Argument ICALL has the following meaning:
    ICALL(1): is used as first argument in subroutines BLOCKF, BLOCKG, BLOCKH,
              BLOCKJ, BLOCKK and BLOCKV. Usually ICALL(1) can be ignored.
              ICALL(1) is set to 0, if one of the input arguments of these
              subroutines, i.e. T, X(T), XD(T), U(T), is changed.
              ICALL(1) can be used to avoid multiple computation of auxiliary
              variables needed in more than one BLOCKx subroutine. Example:
                  SUBROUTINE BLOCKF (ICALL, ...)
                     -- declarations
                  IF ( ICALL(1).EQ.0 ) THEN
                     ICALL(1) = 1
                     -- compute auxiliary variables and store them
                     -- in the user work arrays DUSER, IUSER or LUSER
                  ENDIF
    ICALL(2): On entry ICALL(2) is set to zero BEFORE a new step is
                 encountered, i.e. it is guaranteed that ICALL(2)=0, for the
                 first call of blockF in a step.
              On return ICALL(2) can be modified by subroutine blockF. This
                 value is given as input argument for the successive calls
                 of blockF in the current step. ICALL(2) can be used to
                 detect the first function evaluation in a step.
    ICALL(3): If STEP events cannot occur (INFO(2)=0 in blockB), ICALL(3) is a
              dummy argument. Otherwise:
              On entry
              ICALL(3) = 0: Calculate right hand side.
                            On return ICALL(3) is not used (dummy argument).
                       = 1: Check STEP event condition (an internal step was
                            already completed). However, don't modify F.
                            On return ICALL(3) signals the action to be done:
                            ICALL(3) = 0: Continue integration.
                                     = 1: A STEP event occurs, i.e. integration
                                          is halted and subroutine blockV is
                                          called.
    ICALL(11),...,ICALL(15) are input arguments if HDAE. Otherwise dummy.
    ICALL(10+i) = 0: F_i has not to be calculated (i=1,2,3,4,5).
                = 1: F_i has to be calculated.
                e.g. ICALL(14) = 1 means, that F_4 has to be calculated.
 
Life cycle:
  1990 FEB  N. Gaus, M. Otter, DLR FF-DF: specified
            NLSIM from D. Joos, DLR FF-DF, used as basis.
  1990 JUN  N. Gaus, M. Otter, DLR FF-DF: modified
            DAE/HDAE formulation added
  1990 OCT  N. Gaus, M. Otter, DLR FF-DF: modified
            Event handling added
  1991 FEB  M. Otter, DLR FF-DF         : modified
            Event handling (via INFO) not in BLOCKF but in BLOCKK
  1991 JUN  M. Otter, DLR FF-DF         : modified
            Arguments ICALL(2), ICALL(3) introduced.
  1992 FEB  M. Otter, DLR FF-DF         : modified
            ODAE (Overdetermined DAE) replaced by HDAE (Higher index DAE),
            ICALL(11)..(15) introduced.
            All results via F (and not partly via XD).
            Argument XD moved. Arguments LP and LUSER added.
 
Libraries required:
  user defined
 
Example:
  none
******
_blockg__
SUBROUTINE
BLOCKG, Compute output signals
Procedure purpose:
  In BLOCKG the user has to program the evaluation of the output vector Y
 
   - for ODEs/HDAEs:    Y = G ( T, X(T), <XD(T)>, U(T), DP, IP, LP )
 
   - for DAEs      :    Y = G ( T, X(T), XD(T)  , U(T), DP, IP, LP )

  By default, Y is not a function of XD for ODEs or HDAEs. However, upon
  request (by calling utility subroutine BLO3UX) XD is provided as input
  argument. Dense output integrators determine XD by interpolation. For
  other integrators XD is usually available with no cost, since BLOCKF
  was called just before BLOCKG.
 
  If the dimension of the output vector Y is 0, the subroutine BLOCKG has not
  to be provided. If it is provided, it is not called.
 
Usage:
  CALL BLOCKG (ICALL, T, X, XD, U, DP, IP, LP, Y, DUSER, IUSER, LUSER, IERR)
 
  ICALL :  IN, OUT, INTEGER
           ICALL is used for special applications. See "Remarks" below.
  T     :  IN, DOUBLE
           Simulation time instant.
  X     :  IN, DOUBLE(*)
           Vector X at time T.
  XD    :  IN, DOUBLE(*)
           ODE/HDAE: By default dummy argument. If subroutine BLO3UX was
                     called in BLOCKB with argument GXD=1, XD is provided.
           DAE     : IN, First derivative of vector X at time T.
  U     :  IN, DOUBLE(*)
           Input signals U at time T.
  DP    :  IN, DOUBLE(*)
           Double precision parameters.
  IP    :  IN, INTEGER(*)
           Integer parameters.
  LP    :  IN, LOGICAL(*)
           Logical parameters.
  Y     :  OUT, DOUBLE(NY)
           Output vector.
  DUSER :  IN, OUT, DOUBLE(*)
           Double precision user work array.
  IUSER :  IN, OUT, INTEGER(*)
           Integer user work array.
  LUSER :  IN, OUT, LOGICAL(*)
           Logical user work array.
  IERR  :  IN, OUT, INTEGER
           Error parameter
           On entry  IERR =  0 for programming convenience.
           On return IERR =  0: No error occured.
                          else: Terminate integration, since an error occured.
                                The subroutine has printed an error message.
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  user-defined
 
Remarks:
  - ICALL is used as first argument in subroutines BLOCKF, BLOCKG, BLOCKH,
    BLOCKJ, BLOCKK and BLOCKV. Usually ICALL can be ignored. ICALL is set
    to 0, if one of the input arguments of these subroutines, i.e. T, X(T),
    XD(T), U(T), is changed. ICALL can be used to avoid multiple computation
    of auxiliary variables needed in more than one BLOCKx subroutine. Example:
               SUBROUTINE BLOCKx (ICALL, ...)
                  -- declarations
               IF ( ICALL.EQ.0 ) THEN
                  ICALL = 1
                  -- compute auxiliary variables and store them
                  -- in the user work arrays DUSER, IUSER or LUSER
               ENDIF
 
Life cycle:
  1990 FEB  N. Gaus, M. Otter, DLR FF-DF: specified
            NLSIM from D. Joos, DLR FF-DF, used as basis.
  1990 JUN  N. Gaus, M. Otter, DLR FF-DF: modified
  1992 FEB  M. Otter, DLR FF-DF         : modified
            arguments LP and LUSER added
  1992 MAY  M. Otter, DLR FF-DF         : modified
            argument XD for ODEs/HDAEs  
 
Libraries required:
  user-defined
 
Example:
  none
******
_blockh__
SUBROUTINE
BLOCKH, Compute indicator signals
Procedure purpose:
  In BLOCKH the user has to program the evaluation of the indicator signals Z
 
                  Z = H ( T, X(T), U(T), DP, IP, LP )
 
  The zero crossing of an indicator signal Z(i) is used to define the
  occurence of a state event. If an entry of Z changes its sign during
  integration, the corresponding zero of Z is located (within roundoff) by the
  integrator. Optionally, a state event occurs only in the case an indicator
  signal Z(i) passes through zero in a specified direction (e.g. from negative
  to positive). In this case, the types of crossings must be defined in
  subroutine BLOCKS for the first state events and in BLOCKV for the
  following ones.
 
  If a zero of Z has been located, the integration is halted and user
  subroutine BLOCKV is called to react on the event (e.g. to start
  with new initial conditions).
 
  If the dimension of the indicator vector Z (NZ) is 0, subroutine BLOCKH has
  not to be provided. If it is provided, it is not called.
 
Usage:
  CALL BLOCKH (ICALL, T, X, XD, U, DP, IP, LP, Z, DUSER, IUSER, LUSER, IERR)
 
  ICALL :  IN, OUT, INTEGER
           ICALL is used for special applications. See "Remarks" below.
  T     :  IN, DOUBLE
           Simulation time instant.
  X     :  IN, DOUBLE(*)
           Vector X at time T.
  XD    :  IN, DOUBLE(*)
           At present ALWAYS a dummy argument.
  U     :  IN, DOUBLE(*)
           Input signals U at time T.
  DP    :  IN, DOUBLE(*)
           Double precision parameters.
  IP    :  IN, INTEGER(*)
           Integer parameters.
  LP    :  IN, LOGICAL(*)
           Logical parameters.
  Z     :  OUT, DOUBLE(*)
           Indicator signals Z
  DUSER :  IN, OUT, DOUBLE(*)
           Double precision user work array.
  IUSER :  IN, OUT, INTEGER(*)
           Integer user work array.
  LUSER :  IN, OUT, LOGICAL(*)
           Logical user work array.
  IERR  :  IN, OUT, INTEGER
           Error parameter
           On entry  IERR =  0 for programming convenience.
           On return IERR =  0: No error occured.
                          else: Terminate integration, since an error occured.
                                The subroutine has printed an error message.
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  user-defined
 
Remarks:
  - ICALL is used as first argument in subroutines BLOCKF, BLOCKG, BLOCKH,
    BLOCKJ, BLOCKK and BLOCKV. Usually ICALL can be ignored. ICALL is set
    to 0, if one of the input arguments of these subroutines, i.e. T, X(T),
    XD(T), U(T), is changed. ICALL can be used to avoid multiple computation
    of auxiliary variables needed in more than one BLOCKx subroutine. Example:
               SUBROUTINE BLOCKx (ICALL, ...)
                  -- declarations
               IF ( ICALL.EQ.0 ) THEN
                  ICALL = 1
                  -- compute auxiliary variables and store them
                  -- in the user work arrays DUSER, IUSER or LUSER
               ENDIF
 
Life cycle:
  1990 JUN  N. Gaus, M. Otter, DLR FF-DF: specified
  1990 OCT  N. Gaus, M. Otter, DLR FF-DF: modified
  1991 JAN  M. Otter, DLR FF-DF         : modified
            The task of the original USERCH was split up into
            2 subroutines (BLOCKH, BLOCKV)
  1992 FEB  M. Otter, DLR FF-DF         : modified
            arguments LP and LUSER added
 
Libraries required:
  user-defined
 
Example:
  none
******
_blockj__
SUBROUTINE
BLOCKJ, Compute Jacobian matrix
Procedure purpose:
  Some integration methods need the Jacobian matrix of partial derivatives
  of the right hand side F. Usually this matrix is approximated internally
  by numerical differencing. However, by BLOCKJ this matrix can be evaluated
  analytically which may make the solution of the integrator more reliable.
  Sometimes numerical differencing is cheaper than evaluating derivatives in 
  BLOCKJ and sometimes it is not - this depends on the problem.
 
  In BLOCKJ the user has to program the evaluation of the Jacobian matrix JAC
  (at present a user-defined Jacobian matrix is not supported for HDAEs):
 
  - for ODEs :   JAC(i,j) = dF(i)/dX(j)
 
  - for DAEs :   JAC(i,j) = dF(i)/dX(j) + CJ*dF(i)/dXD(j)
                            where CJ is a constant provided by the
                                  calling program
 
Usage:
  CALL BLOCKJ (ICALL, T, X, XD, U, DP, IP, LP, CJ, JAC, NJAC,
               DUSER, IUSER, LUSER, IERR)
 
  ICALL :  IN, OUT, INTEGER
           ICALL is used for special applications. See "Remarks" below.
  T     :  IN, DOUBLE
           Simulation time instant.
  X     :  IN, DOUBLE(*)
           Vector X at time T.
  XD    :  IN, DOUBLE(*)
           ODE : Dummy Argument
           DAE : IN, First derivative of vector X at time T.
  U     :  IN, DOUBLE(*)
           Input signals U at time T.
  DP    :  IN, DOUBLE(*)
           Double precision parameters.
  IP    :  IN, INTEGER(*)
           Integer parameters.
  LP    :  IN, LOGICAL(*)
           Logical parameters.
  CJ    :  IN, DOUBLE
           ODE : Dummy Argument
           DAE : Method constant needed to calculate JAC.
  JAC   :  OUT, DOUBLE(NJAC,NJAC)
           Calculated Jacobian matrix.
  NJAC  :  IN, INTEGER
           First and second dimension of Jacobian.
           ODE/DAE: NJAC = NX
  DUSER :  IN, OUT, DOUBLE(*)
           Double user work array.
  IUSER :  IN, OUT, INTEGER(*)
           Integer user work array.
  LUSER :  IN, OUT, LOGICAL(*)
           Logical user work array.
  IERR  :  IN, OUT, INTEGER
           Error parameter
           On entry  IERR =  0 for programming convenience.
           On return IERR =  0: No error occured.
                          else: Terminate integration, since an error occured.
                                The subroutine has printed an error message.
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  user-defined
 
Remarks:
  - ICALL is used as first argument in subroutines BLOCKF, BLOCKG, BLOCKH,
    BLOCKJ, BLOCKK and BLOCKV. Usually ICALL can be ignored. ICALL is set
    to 0, if one of the input arguments of these subroutines, i.e. T, X(T),
    XD(T), U(T), is changed. ICALL can be used to avoid multiple computation
    of auxiliary variables needed in more than one BLOCKx subroutine. Example:
               SUBROUTINE BLOCKx (ICALL, ...)
                  -- declarations
               IF ( ICALL.EQ.0 ) THEN
                  ICALL = 1
                  -- compute auxiliary variables and store them
                  -- in the user work arrays DUSER, IUSER or LUSER
               ENDIF
 
Life cycle:
  1990 SEP  N. Gaus, M. Otter, DLR FF-DF: specified
  1992 FEB  M. Otter, DLR FF-DF         : modified
            arguments LP and LUSER added
 
Libraries required:
  user-defined
 
Example:
  none
******
_blockk__
SUBROUTINE
BLOCKK, To be called at every communication point.
Procedure purpose:
  This subroutine is called at every communication point.
  Note that T0 and TEND are also communication points.
 
  By this subroutine one can:
 
  - Stop the integration if a certain condition holds. It makes a difference
    whether the integration is stopped by BLOCKK or by one of the
    subroutines BLOCKF, BLOCKG, BLOCKH or BLOCKJ. In the latter case, you
    have no guarantee whether the signals of the current time instant or of
    one of the previous time instants are stored. This is due to the fact, that
    "dense output" integrators make a step to an internally defined time
    instant Tinteg and determine the signals at communication points by
    interpolation. If the stop condition holds at Tinteg, no communication
    points between the last Tinteg and the current Tinteg are stored. On the 
    other hand, if the integration is stopped by subroutine BLOCKK, it is
    guaranteed that all communication points up to, and including the current
    time instant are stored.
 
  - Calculate additional data at the communication points. For this purpose
    the user can define an auxiliary signal W by the initializing
    subroutine BLOCKB via DIM(5). Actual values of W are computed by
    subroutine BLOCKK. Contrary to output signals Y, signals W cannot be
    used for the connection of models of DSblocks. Signals W are just
    additional "interesting" internal signals which are stored at 
    communication points.
 
Usage:
  CALL BLOCKK (ICALL, T, X, XD, U, DP, IP, LP, W, DUSER, IUSER, LUSER, IERR)
 
  ICALL :  IN, OUT, INTEGER(2)
           ICALL is used for special applications. See "Remarks" below.
  T     :  IN, DOUBLE
           Simulation time instant.
  X     :  IN, DOUBLE(*)
           Vector X at time T.
  XD    :  IN, DOUBLE(*)
           ODE/HDAE: By default dummy argument. If subroutine BLO3UX was
                     called in BLOCKB with argument KXD=1, XD is provided.
           DAE     : IN, First derivative of vector X at time T.
  U     :  IN, DOUBLE(*)
           Input signals U at time T.
  DP    :  IN, DOUBLE(*)
           Double precision parameters.
  IP    :  IN, INTEGER(*)
           Integer parameters.
  LP    :  IN, LOGICAL(*)
           Logical parameters.
  W     :  OUT, DOUBLE(*)
           if ICALL(2) = 1 then
              Actual values of auxiliary signals at time T, if auxiliary
              signals have been defined by BLOCKB.
           else
              Dummy argument (W may be calculated, but it is not used).
           endif
  DUSER :  IN, OUT, DOUBLE(*)
           Double user work array.
  IUSER :  IN, OUT, INTEGER(*)
           Integer user work array.
  LUSER :  IN, OUT, LOGICAL(*)
           Logical user work array.
  IERR  :  IN, OUT, INTEGER
           Error parameter
           On entry  IERR =  0 for programming convenience.
           On return IERR =  0: No error occured.
                          else: Terminate integration, since an error occured.
                                The subroutine has printed an error message.
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  user-defined
 
Remarks:
  - Argument ICALL has the following meaning:
    ICALL(1): is used as first argument in subroutines BLOCKF, BLOCKG, BLOCKH,
              BLOCKJ, BLOCKK and BLOCKV. Usually ICALL(1) can be ignored.
              ICALL(1) is set to 0, if one of the input arguments of these
              subroutines, i.e. T, X(T), XD(T), U(T), is changed.
              ICALL(1) can be used to avoid multiple computation of auxiliary
              variables needed in more than one BLOCKx subroutine. Example:
                  SUBROUTINE BLOCKF (ICALL, ...)
                     -- declarations
                  IF ( ICALL(1).EQ.0 ) THEN
                     ICALL(1) = 1
                     -- compute auxiliary variables and store them
                     -- in the user work arrays DUSER, IUSER or LUSER
                  ENDIF
    ICALL(2): On entry  ICALL(2) = 0: Auxiliary signals W are not stored.
                                 = 1: Auxiliary signals W will be stored.
                                      Calculate W.
              On return ICALL(2) is not used (dummy argument)

Life cycle:
  1990 FEB  N. Gaus, M. Otter, DLR FF-DF: specified
  1990 JUN  N. Gaus, M. Otter, DLR FF-DF: modified
  1990 OCT  N. Gaus, M. Otter, DLR FF-DF: modified
            Array AUX added.
  1991 FEB  M. Otter, DLR FF-DF         : modified
            The task of the original USERSE was split up into
            3 subroutines (BLOCKK, BLOCKS, BLOCKT). Output events are
            defined by BLOCKK and not by BLOCKF.
  1991 JUN  M. Otter, DLR FF-DF         : modified
            Output events replaced by step events. Therefore argument
            INFO of BLOCKK modifed. ICALL(2) introduced to avoid
            unnecessary computation of DAUX.
  1992 FEB  M. Otter, DLR FF-DF         : modified
            New arguments LP and LUSER. INFO changed to IERR.
            DAUX changed to W.
  1992 MAY  M. Otter, DLR FF-DF         : modified
            argument XD for ODEs/HDAEs  
 
Libraries required:
  user-defined
 
Example:
  none
******
_blockp__
SUBROUTINE
BLOCKP, Check parameter set
Procedure purpose:
  By this subroutine the user can check the parameter set of the model
  (e.g. whether a parameter is in a specified interval).
 
  The subroutine is called if any one of the parameters is changed
  (via dialog) and after the dialog environment to change the parameters
  is left.
 
  If none of the parameters must be checked, this subroutine needs not to be
  provided.
 
Usage:
  CALL BLOCKP (DP,IP,LP,ITYP,IPT,IPOS,NDIM,DIM,X0,XD0,DUSER,IUSER,LUSER,
               IERR)
 
  DP    :  IN, DOUBLE(*)
           Double precision parameters.
  IP    :  IN, INTEGER(*)
           Integer parameters.
  LP    :  IN, LOGICAL(*)
           Logical parameters.
  ITYP  :  IN, INTEGER
           = 0: The environment to change the parameter set is terminated.
           = 1: An Integer parameter was changed.
           = 2: A Logical parameter was changed.
           = 3: A Double parameter was changed.
  IPT   :  IN, INTEGER
           If the parameter is a scalar, IPT is the position of the modified
           parameter with respect to vectors DP, IP or LP according to ITYP.
           If the parameter is an array, IPT is the starting address of the
           parameter array with respect to vectors DP, IP or LP according to
           IPT. IPT=0, if the environment to change the parameter set is
           terminated.
  IPOS  :  IN, INTEGER
           Number of parameter, according to the definition sequence of the 
           parameters by subroutines BLO3Px and BLO3Rx. IPOS=0, if the
           environment to change the parameter set is terminated.
  NDIM  :  IN, INTEGER, 0 <= NDIM <= 6
           Number of dimensions of the modified parameter.
  DIM   :  IN, INTEGER DIM(*)
	   Actual values of dimensions of the modified parameter.
  X0    :  IN, OUT, DOUBLE(*)
           Vector for initial conditions X(T0) (may be modified)
  XD0   :  IN, OUT, DOUBLE(*)
           if DAE then
              Vector for initial conditions XD(T0) (may be modified)
           else
              dummy argument
           endif
  DUSER :  IN, OUT, DOUBLE(*)
           Double precision user work array.
  IUSER :  IN, OUT, INTEGER(*)
           Integer user work array.
  LUSER :  IN, OUT, LOGICAL(*)
           Logical user work array.
  IERR  :  IN, OUT, INTEGER
           Error parameter
           On entry IERR=0 for programming convenience. On return IERR
           =  0: No error occurred in the subroutine.
           =  1: Warning, but the new parameter value will be used.
                 The subroutine has printed a warning message.
           =  2: Error, the new parameter value will not be used.
                 The subroutine has printed an error message.
           =  3: Parameter value is allowed, but it will not be used.

Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  user-defined
 
Remarks:
  user-defined subroutine
 
Life cycle:
  1990 FEB  N. Gaus, M. Otter, DLR FF-DF: specified
  1990 JUN  N. Gaus, M. Otter, DLR FF-DF: modified
  1992 FEB  M. Otter, DLR FF-DF         : modified
            arguments LP and LUSER added
  1992 MAY  M. Otter, DLR FF-DF         : modified
            arguments NDIM, DIM, X0, XD0  added
 
Libraries required:
  user-defined
 
Example:
  none
******
_blocks__
SUBROUTINE
BLOCKS, To be called before integration starts (initial section)
Procedure purpose:
  If this subroutine is provided, it is called before an
  integration starts.
 
  By this subroutine one may:
 
  - Define the first time event.
  - Define the crossing direction of the indicator signals for the first
    state event.
  - Check or modify the initial conditions X(T0), XD(T0) (for DAEs).
    If new initial conditions are defined, these values replace
    the values defined by BLOCKB or defined via dialog. 
  - Modify actual dimensions of state vector X or of vector of indicator
    signals Z.
  - Initialize internal variables before the integration starts.
  - Copy the actual parameter set DP/IP/LP into the internal data structure
    of the user. (Although the actual parameter set DP/IP/LP are also given
    as arguments to subroutines BLOCKF, BLOCKG, BLOCKH, BLOCKJ and BLOCKK,
    it is more efficient to do the copy operation by BLOCKS just once before
    the integration starts and ignore arguments DP/IP/LP in the other DSblock
    subroutines).
 
Usage:
  CALL BLOCKS (T0, X0, XD0, U0, DP, IP, LP, TEVENT, HCROSS, DIMNEW,
               DUSER, IUSER, LUSER, IERR)
 
  T0    :  IN, DOUBLE
           Initial time
  X0    :  IN, OUT, DOUBLE(*)
           Vector X at initial time T0.
           Can be modified by BLOCKS.
  XD0   :  IN, OUT, DOUBLE(*)
           ODE/HDAE: Dummy Argument
           DAE     : First derivative of state vector X at time T0.
                     Can be modified by BLOCKS.
  U0    :  IN, DOUBLE(*)
           Input signals U at time T0.
  DP    :  IN, DOUBLE(*)
           Double precision parameters.
  IP    :  IN, INTEGER(*)
           Integer parameters.
  LP    :  IN, LOGICAL(*)
           Logical parameters.
  TEVENT:  IN, OUT, DOUBLE(2)
           On entry  TEVENT(1)/(2)=T0 for programming convenience.
           On return TEVENT(1) > T0 is the first time event. If the first time
                     event is defined (TEVENT(1)>T0) and TEVENT(2) > TEVENT(1),
                     dense output integrators integrate beyond TEVENT(1) and
                     determine the signals at the event point by interpolation.
                     However, the integrators will not integrate past TEVENT(2).
                     TEVENT(2) is useful for efficiency reasons, if the model
                     does not change its structure at the event point TEVENT(1),
                     i.e. if the integration continues after the event.
  HCROSS:  IN, OUT, INTEGER(*)
           if no indicator signals defined (NZ=0) then
              dummy argument
           else
              On entry : HCROSS(i) = 0 (i=1,2,..,NZ) for programming convenience
              On return: HCROSS(i) = 0: Next state event occurs if
                                        Z(i) passes through zero.
                                   = 1: Next state event occurs if
                                        Z(i) passes through zero from
                                        negative to positive.
                                   =-1: Next state event occurs, if
                                        Z(i) passes through zero from
                                        positive to negative.
           endif
  DIMNEW:  IN, OUT, INTEGER(2)
           On entry  DIMNEW(1) = NXMAX
                           (2) = NZMAX for programming convenience
                     (NXMAX, NZMAX are defined in BLOCKB)
           On return DIMNEW may be changed, i.e. the dimension of the state
                     vector NX or the number of indicator functions NZ may be
                     modified
  DUSER :  IN, OUT, DOUBLE(*)
           Double precision user work array.
  IUSER :  IN, OUT, INTEGER(*)
           Integer user work array.
  LUSER :  IN, OUT, LOGICAL(*)
           Logical user work array.
  IERR  :  IN, OUT, INTEGER
           Error parameter
           On entry  IERR =  0 for programming convenience.
           On return IERR =  0: No error occured.
                          else: Terminate integration, since an error occured.
                                The subroutine has printed an error message.
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  user-defined
 
Remarks:
  user-defined subroutine
 
Life cycle:
  1990 FEB  N. Gaus, M. Otter, DLR FF-DF: specified
  1990 JUN  N. Gaus, M. Otter, DLR FF-DF: modified
  1990 OCT  N. Gaus, M. Otter, DLR FF-DF: modified
            Array AUX added.
  1991 FEB  M. Otter, DLR FF-DF         : modified
            The task of the original USERSE was split up into
            3 subroutines (BLOCKK, BLOCKS, BLOCKT).
            Meaning of INFO slightly modified.
  1991 MAR  M. Otter, DLR FF-DF         : modified
            INFO = -3, -4 and EVEPS introduced
  1992 FEB  M. Otter, DLR FF-DF         : modified
            Removed arguments IEVENT, TEVENT(1),(2) on entry.
            Argument NXNEW changed to DIMNEW(2).
            Argument INFO modified and renamed to IERR.
  1992 MAY  M. Otter, DLR FF-DF         : modified
            TEVENT(2) introduced
 
Libraries required:
  user-defined
 
Example:
  none
******
_blockt__
SUBROUTINE
BLOCKT, To be called after integration terminated (terminal section)
Procedure purpose:
  If this subroutine is provided, it is called after an integration
  terminated (successfully or abnormally).
 
Usage:
  CALL BLOCKT (IOPT, T, X, XD, U, DP, IP, LP, DUSER, IUSER, LUSER, IERR)
 
  IOPT  :  IN, INTEGER
           Option parameter
           = 1: The integration has been terminated successfully.
           = 2: The integration has been terminated abnormally, before
                reaching TEND.
  T     :  IN, DOUBLE
           Simulation time instant, at which the integration terminated.
  X     :  IN, DOUBLE(*)
           Vector X at time T.
  XD    :  IN, DOUBLE(*)
           ODE/HDAE: Dummy Argument
           DAE     : First derivative of X at time T.
  U     :  IN, DOUBLE(*)
           Input signals U at time T.
  DP    :  IN, DOUBLE(*)
           Double precision parameters.
  IP    :  IN, INTEGER(*)
           Integer parameters.
  LP    :  IN, LOGICAL(*)
           Logical parameters.
  DUSER :  IN, OUT, DOUBLE(*)
           Double precision user work array.
  IUSER :  IN, OUT, INTEGER(*)
           Integer user work array.
  LUSER :  IN, OUT, LOGICAL(*)
           Logical user work array.
  IERR  :  IN, OUT, INTEGER
           Error parameter
           On entry  IERR =  0 for programming convenience.
           On return IERR =  0: No error occured.
                          else: Terminate integration, since an error occured.
                                The subroutine has printed an error message.
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  user-defined
 
Remarks:
  user-defined subroutine
 
Life cycle:
  1990 FEB  N. Gaus, M. Otter, DLR FF-DF: specified
  1990 JUN  N. Gaus, M. Otter, DLR FF-DF: modified
  1990 OCT  N. Gaus, M. Otter, DLR FF-DF: modified
            Array AUX added.
  1991 JAN  M. Otter, DLR FF-DF         : modified
            The task of the original USERSE was split up into
            3 subroutines (BLOCKK, BLOCKS, BLOCKT)
  1991 JUN  M. Otter, DLR FF-DF         : modified
            If no auxiliary signals to be stored NDIM2=1.
            Modification of argument SNAME allowed.
  1992 FEB  M. Otter, DLR FF-DF         : modified
            Arguments SNAME, RAUX, DAUX, NDIM1, NDIM2, IPREC removed.
 
Libraries required:
  user-defined
 
Example:
  none
******
_blockv__
SUBROUTINE
BLOCKV, To be called after a time-, state- or step event occured (discrete section)
Procedure purpose:
  If this subroutine is provided, it is called
 
  - if a time event occurs,
  - if a state event occurs, defined as the zero of an indicator function Z
    (BLOCKH),
  - if a step event occurs, defined in subroutine BLOCKF.
 
  In all cases the integration is halted and subroutine BLOCKV is called
  to perform a user defined action, e.g. to define the next time event.
  If an event occurs, all functions describing the model (e.g. BLOCKF) can
  change their structure. Also the number of differential equations NF = NX
  can change. Before leaving BLOCKV it is defined whether the integrator
 
  - continues without any changes,
  - restarts the integration,
  - restarts the integration with new initial conditions provided by BLOCKV,
  - restarts the integration with the number of differential equations
    modified and new initial conditions provided,
  - must be terminated.

  If several different types of events occur at the same time, subroutine
  BLOCKV is called exactly once. The different event types are signaled
  via argument IOPT.
 
  If no events can occur, subroutine BLOCKV needs not to be provided. If it is
  provided, it is not called.
 
Usage:
  CALL BLOCKV (ICALL, IOPT, T, X, XD, U, DP, IP, LP, Z, HINFO, TEVENT,
               HCROSS, DIMNEW, IPRIOR, DUSER, IUSER, LUSER, INFO)
 
  ICALL :  IN, OUT, INTEGER
           ICALL is used for special applications. See "Remarks" below.
  IOPT  :  IN, INTEGER(3)
           Option parameter
           IOPT(1) = 0/1: No/a time  event occured.
               (2) = 0/1: No/a state event occured (defined by BLOCKH).
               (3) = 0/1: No/a step  event occured (defined by BLOCKF).
  T     :  IN, DOUBLE
           Actual simulation time instant.
  X     :  IN, OUT, DOUBLE (*)
           On entry vector X at time T.
           On return X may be modified and is the new initial vector X0.
  XD    :  IN, OUT, DOUBLE(*)
           ODE/HDAE: Dummy Argument
           DAE     : On entry  first derivative of X at time T.
                     On return XD may be modified and is the new 
                     initial vector XD0.
  U     :  IN, DOUBLE(*)
           Input signals U at time T.
  DP    :  IN, DOUBLE(*)
           Double precision parameters.
  IP    :  IN, INTEGER(*)
           Integer parameters.
  LP    :  IN, LOGICAL(*)
           Logical parameters.
  Z     :  IN, DOUBLE(*)
           IOPT=1,3: Dummy argument
           IOPT=  2: Z(1),..., Z(NZ) are the indicator signals at time T.
  HINFO :  IN, INTEGER(*)
           IOPT=1,3: Dummy argument.
           IOPT=  2: HINFO(i)=0: Z(i) is not zero.
                             =1: Z(i) is zero (with respect to machine
                                 precision). It is guaranteed that
                                     Z_last(i) * Z(i) .LE. 0
                                 where Z_last(i) is the value of Z(i) in the
                                 previous step of the integrator.
  TEVENT:  IN, OUT, DOUBLE(2)
           IOPT=2,3: Dummy argument
           IOPT=  1:
           On entry  TEVENT(1)/(2)=T for programming convenience.
           On return TEVENT(1) > T is the next time event. If the next time
                     event is defined (TEVENT(1)>T) and TEVENT(2) > TEVENT(1),
                     dense output integrators integrate beyond TEVENT(1) and
                     determine the signals at the event point by interpolation.
                     However, the integrators will not integrate past TEVENT(2).
                     TEVENT(2) is useful for efficiency reasons, if the model
                     does not change its structure at the event point TEVENT(1),
                     i.e. if the integration continues after this event.
  HCROSS:  IN, OUT, INTEGER(*)
           IOPT=1,3: Dummy argument
           IOPT=  2: On entry : HCROSS(i) has the same value as from the
                                previous call. On the first call of BLOCKV with
                                IOPT=2, HCROSS(i) has the value defined by
                                BLOCKS (IOPT=1). If BLOCKS is not provided
                                HCROSS(i)=0 on the first call.
                     On return: HCROSS(i) = 0: Next state event occurs if
                                               Z(i) passes through zero.
                                          = 1: Next state event occurs if
                                               Z(i) passes through zero from
                                               negative to positive.
                                          =-1: Next state event occurs if
                                               Z(i) passes through zero from
                                               positive to negative.
  DIMNEW:  IN, OUT, INTEGER(2)
           On entry  DIMNEW(1) = NX
                           (2) = NZ for programming convenience
                     (NX, NZ are the actual dimensions)
           On return DIMNEW may be changed, i.e. the dimension of the state
                     vector NX or the number of indicator functions NZ may be
                     modified
  IPRIOR:  IN, OUT, INTEGER
           Priority of event; 0 < IPRIOR <= 100. Normal priority is 50.
           Low priority is 100, high priority is 1.
           On entry  IPRIOR=50, for programming convenience.
           On return IPRIOR may be changed.
           The event priority can be used for the control of output. E.g.:
           Store event points with priority IPRIOR .LE. given value
           (if value=0, store no events, if value=100 store all events).
  DUSER :  IN, OUT, DOUBLE(*)
           Double precision user work array.
  IUSER :  IN, OUT, INTEGER(*)
           Integer user work array.
  LUSER :  IN, OUT, LOGICAL(*)
           Logical user work array.
  INFO  :  OUT, INTEGER
           Information parameter
           INFO = 0: Continue integration without any changes.
                = 1: Restart integration.
                = 2: Stop integration.
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  user-defined
 
Remarks:
  - ICALL is used as first argument in subroutines BLOCKF, BLOCKG, BLOCKH,
    BLOCKJ, BLOCKK and BLOCKV. Usually ICALL can be ignored. ICALL is set
    to 0, if one of the input arguments of these subroutines, i.e. T, X(T),
    XD(T), U(T), is changed. ICALL can be used to avoid multiple computation
    of auxiliary variables needed in more than one BLOCKx subroutine. Example:
               SUBROUTINE BLOCKx (ICALL, ...)
                  -- declarations
               IF ( ICALL.EQ.0 ) THEN
                  ICALL = 1
                  -- compute auxiliary variables and store them
                  -- in the user work arrays DUSER, IUSER or LUSER
               ENDIF
 
Life cycle:
  1990 JUN  N. Gaus, M. Otter, DLR FF-DF: specified
  1990 OCT  N. Gaus, M. Otter, DLR FF-DF: modified
  1991 FEB  M. Otter, DLR FF-DF         : modified
            The task of the original USERCH was split up into
            2 subroutines (BLOCKH, BLOCKV).
            Meaning of INFO slightly modified.
  1991 APR  M. Otter, DLR FF-DF         : modified
            INFO(2),(3),(4) and EVEPS introduced
  1992 FEB  M. Otter, DLR FF-DF         : modified
            Argument IEVENT, TEVENT (on entry) removed.
            Argument NXNEW changed to DIMNEW(2).
            New Argument IPRIOR (formerly INFO(4))
            Argument INFO(1),..,(4) changed to INFO.
  1992 MAR  M. Otter, DLR FF-DF         : modified
            IOPT changed to IOPT(3), i.e. if different events occur
            at the same time, BLOCKV is called once (and not for every
            event type once).
  1992 MAY  M. Otter, DLR FF-DF         : modified
            TEVENT(2) introduced
 
Libraries required:
  user-defined
 
Example:
  none
******
_utility_blo1dt__
SUBROUTINE
BLO1DT, Set description text and version number for a DSblock
Procedure purpose:
  A short description text and a version number for a DSblock can be
  defined. This text is listed in the simulation environment if the
  DSblock is referenced.

  It is only allowed to call this subroutine in subroutine BLOCKB, if IOPT=1.
 
Usage:
  CALL BLO1DT (DTEXT, VERS)
 
  DTEXT :  IN, CHARACTER*(*), LEN(DTEXT) <= 132
           Short description text to describe the DSblock.
  VERS  :  IN, CHARACTER*(*), LEN(VERS) <= 8
           Version number of DSblock (e.g. VERS = '1.1')
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  none
 
Remarks:
  none
 
Life cycle:
  1992 FEB  M. Otter, DLR FF-DF: specified
 
Libraries required:
  depends on simulation environment
 
Example:
  none
******
_utility_blo1ht__
SUBROUTINE
BLO1HT, Define file, the help text for a DSblock is to be found
Procedure purpose:
  For every DSblock a file may be present, which contains a description of
  the DSblock. The content of this file is used as helptext for the DSblock
  in the simulation environment. With subroutine BLO1HT the name of this
  file is defined.

  It is only allowed to call this subroutine in subroutine BLOCKB, if IOPT=1.
 
Usage:
  CALL BLO1HT (FILE)

  FILE  :  IN, CHARACTER*(*)
           Name of help text file. If the file name has on of the forms
             FILE = '$NAMEx....' (x is not a letter or a digit)
                  = '${NAME}...'
                  = '$(NAME)...'
           the string NAME is first replaced by the value of the 
           corresponding environment variable NAME. Example:
              FILE = '${DSBLOCK}/help/test1.t' 
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  none
 
Remarks:
  none
 
Life cycle:
  1992 MAR  M. Otter, DLR FF-DF: specified
 
Libraries required:
  depends on simulation environment
 
Example:
  none
******
_utility_blo2dt__
SUBROUTINE
BLO2DT, Set description text and version number for a model of a DSblock
Procedure purpose:
  A short description text and a version number for a specific model of
  a DSblock can be defined. This text is listed in the simulation environment
  if the model is referenced.

  It is only allowed to call this subroutine in subroutine BLOCKB, if IOPT=2.
 
Usage:
  CALL BLO2DT (DTEXT, VERS)
 
  DTEXT :  IN, CHARACTER*(*), LEN(DTEXT) <= 132
           Short description text to describe the model.
  VERS  :  IN, CHARACTER*(*), LEN(VERS) <= 8
           Version number of the model (e.g. VERS = '1.1')
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  none
 
Remarks:
  none
 
Life cycle:
  1992 FEB  M. Otter, DLR FF-DF: specified
 
Libraries required:
  depends on simulation environment
 
Example:
  none
******
_utility_blo2ht__
SUBROUTINE
BLO2HT, Define file, the help text for a model of a DSblock is to be found
Procedure purpose:
  For every model of a DSblock a file may be present, which contains a
  description of the model. The content of this file is used as helptext for
  the model in the simulation environment. With subroutine BLO2HT the name
  of this file is defined.

  It is only allowed to call this subroutine in subroutine BLOCKB, if IOPT=2.
 
Usage:
  CALL BLO2HT (FILE)

  FILE  :  IN, CHARACTER*(*)
           Name of help text file. If the file name has on of the forms
             FILE = '$NAMEx....' (x is not a letter or a digit)
                  = '${NAME}...'
                  = '$(NAME)...'
           the string NAME is first replaced by the value of the 
           corresponding environment variable NAME. Example:
              FILE = '${DSBLOCK}/help/test1.t' 
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  none
 
Remarks:
  none
 
Life cycle:
  1992 MAR  M. Otter, DLR FF-DF: specified
 
Libraries required:
  depends on simulation environment
 
Example:
  none
******
_utility_blo2mf__
SUBROUTINE
BLO2MF, Inquire name of file on which additional data of a model is stored
Procedure purpose:
  The name of a file is inquired, on which additional data of a model
  is stored. The data can be read from this file in the following way:

     1. Inquire free logical unit number by subroutine BLOLUB.
     2. Open the file.
     3. Read the content of the file with READ-statements.
     4. Close the file.
     5. Return the logical unit number by subroutine BLOLUC.

  It is only allowed to call this subroutine in subroutine BLOCKB, if IOPT=2.
 
Usage:
  CALL BLO2MF (PROMPT, FILE)
 
  PROMPT:  IN, CHARACTER*(*), LEN(PROMPT) <= 132
           Prompt text
  FILE  :  OUT, CHARACTER*(*)
           Name of file, defined via dialog. If FILE=' ', an error occured,
           or no filename was given. If the given file name has on of the forms
             FILE = '$NAMEx....' (x is not a letter or a digit)
                  = '${NAME}...'
                  = '$(NAME)...'
           the string NAME is first replaced by the value of the 
           corresponding environment variable NAME before return. Example:
              FILE = '${DSBLOCK}/model/test1.t' 
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  none
 
Remarks:
  none
 
Life cycle:
  1992 FEB  M. Otter, DLR FF-DF: specified
 
Libraries required:
  depends on simulation environment
 
Example:
  none
******
_utility_blo3d__
SUBROUTINE
BLO3DD/E/I, Set default values for variables of the simulation environment
Procedure purpose:
  In the simulation environment default values are set for several
  important variables. With subroutines BLO3Dx modified default values
  can be provided.

  If the simulation environment does not support a required variable,
  the subroutine call of BLO3Dx is ignored.

  It is only allowed to call subroutines BLO3Dx in subroutine
  BLOCKB, if IOPT=3.
 
Usage:
  CALL BLO3DD (TYPE, DVAL)
  CALL BLO3DE (TYPE, DVEC, NVEC)
  CALL BLO3DI (TYPE, IVAL)
 
  TYPE  :  IN, INTEGER
	   Type of variable, for which a default value is provided.
           Allowed values are:
           BLO3DD: TYPE = 1: Final simulation time.
                          2: Communication stepsize.
                          3: Stepsize proposed for the first step.
                          4: Minimum absolute stepsize
                          5: Maximum absolute stepsize
                          6: Relative tolerance for vector X.
                          7: If delayed signals are present, signals are
                             only stored in a delay buffer at time t1, if
                             t1 > t2+DVAL, where t2 is the time instant
                             of the previously stored signal.

           BLO3DE: TYPE = 1: DVEC(i) is scaling vector for X(i), such that
                             X(i)/DVEC(i) is in the order of 1.

           BLO3DI: TYPE = 1: Integration is halted, if IVAL number of
                             evaluations of BLOCKF subroutine is reached.
                             If IVAL<=0, no limits exist.
                        = 2: Maximum order of integration method, if method
                             has a variable order.
                        = 3: IVAL= 0: If possible use a non-stiff integrator
                                      as default method
                                 = 1: If possible use a stiff integrator as
                                      default method
                        = 4: IVAL= 1: Integrators step always exactly to a
                                      communication point and restart
                                      afterwards.
                                 = 2: Integrators step always exactly to a 
                                      communication point and continue.
                                 = 3: Dense-output integrators determine
                                      signals at communication points by
                                      interpolation and continue.
                        = 5: Precision of result data (which is stored on file
                             or on database)
                             IVAL=2: REAL
                                 =3: DOUBLE PRECISION
                        = 6: Number of communication intervals.
  DVAL  :  IN, DOUBLE
           Double precision value, according to TYPE.
  DVEC  :  IN, DOUBLE(NVEC)
           Double precision vector, according to TYPE.
  NVEC  :  IN, INTEGER
           Dimension of DVEC.
  IVAL  :  IN, INTEGER
           Integer value, according to TYPE.
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  none
 
Remarks:
  none
 
Life cycle:
  1992 FEB  M. Otter, DLR FF-DF: specified
  1992 MAR  M. Otter, DLR FF-DF: modified
            Type of value via Integer and not via Character argument
  1992 MAY  M. Otter, DLR FF-DF: modified
            New IVAL=-1 for TYPE=4 for BLO3DI.
            New TYPE=6 for BLO3DI.
  1994 APR  M. Otter, DLR FF-DF: modified
            Scalar absolute tolerance and relative and absolute tolerance
            vectors removed. Replaced by scaling of x-vector. 
            New TYPE=4 for BLO3DI.

Libraries required:
  depends on simulation environment
 
Example:
        INTEGER     PTEND, PTOLA, PFMAX
        PARAMETER  (PTEND = 1, PTOLA = 6, PFMAX = 1)
           ...
        CALL BLO3DD (PTEND, 10.0D0)
        CALL BLO3DD (PTOLA, 1.D-6)
        CALL BLO3DI (PFMAX, 10000)
******
_utility_blo3m__
SUBROUTINE
BLO3MD/MI, Define minimum and maximum values for parameters
Procedure purpose:
  With subroutines BLO3MD and BLO3MI minimum and maximum values can be
  defined for the parameters of type DOUBLE PRECISION or type INTEGER.
  The simulation environment guarantees, that modified parameters
  are in the defined range. The subroutines have to be called at once,
  after the corresponding parameter has been defined via BLO3Px/Rx. 

  It is only allowed to call BLO3MD, BLO3MI in subroutine BLOCKB, if IOPT=3.

Usage:
  CALL BLO3MD (DMIN,DMAX,MIN,MAX)
  CALL BLO3MI (IMIN,IMAX,MIN,MAX)
 
  DMIN  :  IN, DOUBLE
	   Minimum value if MIN > 0
  IMIN  :  IN, INTEGER
	   Minimum value if MIN > 0
  DMAX  :  IN, DOUBLE
	   Maximum value if MAX > 0
  IMAX  :  IN, INTEGER
	   Maximum value if MAX > 0
  MIN   :  IN, INTEGER
           MIN = 0: No minimum defined
               = 1: DMIN <  array elements of parameter required
               = 2: DMIN <= array elements of parameter required
  MAX   :  IN, INTEGER
           MAX = 0: No maximum defined
               = 1: DMAX >  array elements of parameter required
               = 2: DMAX >= array elements of parameter required
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  none
 
Remarks:
  none
 
Life cycle:
  1992 MAY  M. Otter, DLR FF-DF: specified
 
Libraries required:
  depends on simulation environment
 
Example:
  see BLO3Px
******
_utility_blo3p__
SUBROUTINE
BLO3PD/PI/PL/RD/RI/RL, Define parameters
Procedure purpose:
  With subroutines BLO3Px and BLO3Rx the parameters (system constants)
  of a DSblock are defined. A parameter can be of type DOUBLE PRECISION,
  INTEGER or LOGICAL and can be a scalar or an array with upto 6 dimensions.
  The values of all parameters can be modified by the simulation 
  environment (either via dialog, or via a program, e.g. by parameter
  optimization).

  The actual values of all parameters are stored in a DOUBLE PRECISION
  vector DP, INTEGER vector IP and LOGICAL vector LP. The mapping on
  these 3 vectors is done according to the definition sequence of the
  parameters. Furthermore arrays are mapped according to the FORTRAN
  definition (columnwise). See also "Example" below.

  Default values of parameters are defined via arguments DP, IP, LP,
  when subroutine BLOCKB is called with IOPT=3.
 
  It is only allowed to call BLO3Px, BLO3Rx in subroutine BLOCKB, if IOPT=3.

Usage:
  CALL BLO3PD (NAME,DTEXT)            -- scalar double  parameter
  CALL BLO3PI (NAME,DTEXT)            -- scalar integer parameter
  CALL BLO3PL (NAME,DTEXT)            -- scalar logical parameter
  CALL BLO3RD (NAME,DTEXT,NDIM,DIM)   -- array  double  parameter
  CALL BLO3RI (NAME,DTEXT,NDIM,DIM)   -- array  integer parameter
  CALL BLO3RL (NAME,DTEXT,NDIM,DIM)   -- array  logical parameter
 
  NAME  :  IN, CHARACTER*(*)
           Name of parameter I. NAME has to be a valid Fortran'90 name.
           That is, only uppercase letters, digits and underscore '_' are
           allowed. The first character has to be a letter. The name has to
           consist of at most 31 characters. 
           The name of parameter I has to be unique with respect to the
           names of all other parameters and of the names of all signals.
  DTEXT :  IN, CHARACTER*(*), LEN(DTEXT) <= 132
           Short description text of parameter I.
  NDIM  :  IN, INTEGER, 1 <= NDIM <= 6
           Number of dimensions of parameter I.
  DIM   :  IN, INTEGER DIM(NDIM)
           Actual values of dimensions of parameter I.
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  none
 
Remarks:
  none
 
Life cycle:
  1992 FEB  M. Otter, DLR FF-DF: specified
  1992 MAR  M. Otter, DLR FF-DF: modified
	    Default values of parameters via subroutine BLOCKB.
 
Libraries required:
  depends on simulation environment
 
Example:
        SUBROUTINE TESTB (...)
            ...
        INTEGER    LT  , LE  , GT
        PARAMETER (LT=1, LE=2, GT=1)
        INTEGER    DIMA(2)
        SAVE       DIMA
        DATA       DIMA /2, 3/
            ...
        IF ( IOPT .EQ. 1 ) THEN
           ...
        ELSEIF ( IOPT .EQ. 2 ) THEN
           ...
  C        Number of parameters (= DNUM1/INUM1/DARRAY/INUM2/DNUM2)
             SIG(6) = 5
  C
  C        Dimensions of vectors DP/IP/LP
             DIM(6) = 8
             DIM(7) = 2
             DIM(8) = 0
           ...
        ELSEIF ( IOPT .EQ. 3 ) THEN
  C        Define names, types and description texts of the parameters
  C        (0 <= NUM1 
  C         5 <  DARRAY(i,j) < 30)
             CALL BLO3PD ('DNUM1 ', 'Double  value 1 in [m/s]')
             CALL BLO3MD            (0.0D0,0.0D0,LE,0)
             CALL BLO3PI ('INUM1 ', 'Integer value 1         ')
             CALL BLO3RD ('DARRAY', 'Double  array           ', 2,DIMA)
             CALL BLO3MD            (5.0D0,30.0D0,LT,GT)
             CALL BLO3PI ('INUM2 ', 'Integer value 2         ')
             CALL BLO3PD ('DNUM2 ', 'Double  value 2 in [kg] ')
  C
  C        Define default values of the parameters
  C          DNUM1  = 0
  C          INUM1  = 1
  C          DARRAY = < 11, 12, 13
  C                     21, 22, 23 >
  C          INUM2  = 2
  C          DNUM2  = 50
  C
             DP (1) =  0.D0
             DP (2) = 11.D0
             DP (3) = 21.D0
             DP (4) = 12.D0
             DP (5) = 22.D0
             DP (6) = 13.D0
             DP (7) = 23.D0
             DP (8) = 50.D0
             IP (1) = 1
             IP (2) = 2
           ...
        ENDIF

  In the simulation environment the parameters are listed in the following way: 

       DNUM1, INUM1, DARRAY, INUM2, DNUM2
******
_utility_blo3s__
SUBROUTINE
BLO3SU/SW/SX/SY/SZ/TU/TW/TX/TY/TZ, Define signals
Procedure purpose:
  With subroutines BLO3Sx and BLO3Tx the signals of a DSblock are defined.
  A signal can be a scalar or an array with upto 6 dimensions. The actual values
  of signals at a time instant T are stored in DOUBLE PRECISION vectors U, W, X,
  Y and Z respectively. The mapping on these vectors is done according to the
  definition sequence of the signals via BLO3Sx/BLO3Tx. Furthermore arrays are
  mapped according to the Fortran definition (columnwise). See also "Example"
  below. These vectors have the following meaning:

     U: Input signals
     W: Auxiliary signals                                             
     X: State signals
     Y: Output signals (the only signals which can be used in a connection
                        of DSblocks)
     Z: Indicator signals (zero crossing defines state events)

  Initial values for signals X or signals XD (= derivative of X) are defined
  via arguments X0, XD0, when subroutine BLOCKB is called with IOPT=3.
 
  It is only allowed to call BLO3Sx, BLO3Tx in subroutine BLOCKB, if IOPT=3.
                                                        
Usage:
  CALL BLO3SU (NAME,DTEXT)           -- define scalar signals U
  CALL BLO3SW (NAME,DTEXT)           -- define scalar signals W
  CALL BLO3SX (NAME,DTEXT)           -- define scalar signals X
  CALL BLO3SY (NAME,DTEXT)           -- define scalar signals Y
  CALL BLO3SZ (NAME,DTEXT)           -- define scalar signals Z
  CALL BLO3TU (NAME,DTEXT,NDIM,DIM)  -- define array  signals U
  CALL BLO3TW (NAME,DTEXT,NDIM,DIM)  -- define array  signals W
  CALL BLO3TX (NAME,DTEXT,NDIM,DIM)  -- define array  signals X
  CALL BLO3TY (NAME,DTEXT,NDIM,DIM)  -- define array  signals Y
  CALL BLO3TZ (NAME,DTEXT,NDIM,DIM)  -- define array  signals Z
                          
  NAME  :  IN, CHARACTER*(*)
           Name of signal I. NAME has to be a valid FORTRAN'90 name.
           That is, only uppercase letters, digits and underscore '_' are
           allowed. The first character has to be a letter. The name has to
           consist of at most 31 characters. 
           The name of signal I has to be unique with respect to the
           names of all other signals and of the names of all parameters.
  DTEXT :  IN, CHARACTER*(*), LEN(DTEXT) <= 132
           Short description text of signal I.
  NDIM  :  IN, INTEGER, 1 <= NDIM <= 6
           Number of dimensions of signal I.
  DIM   :  IN, INTEGER DIM(NDIM)
           Actual values of dimensions of signal I.
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  none
 
Remarks:
  none
 
Life cycle:
  1992 FEB  M. Otter, DLR FF-DF: specified
  1992 MAR  M. Otter, DLR FF-DF: modified
            Signals can be arrays.
            For every signal a name has to be provided.
 
Libraries required:
  depends on simulation environment
 
Example:
        SUBROUTINE TESTB (...)
            ...
        INTEGER  DIMA(2)
        SAVE     DIMA
        DATA     DIMA /3, 3/
            ...
        IF ( IOPT .EQ. 1 ) THEN
           ...
        ELSEIF ( IOPT .EQ. 2 ) THEN
           ...
  C        Number of signals X/U/Y/Z/W 
             SIG(1) =  4
             SIG(2) =  1
             SIG(3) =  2
             SIG(4) =  0
             SIG(5) =  0
  C
  C        Dimensions of vectors X/U/Y/Z/W
             DIM(1) =  4
             DIM(2) =  2
             DIM(3) = 12
             DIM(4) =  0
             DIM(5) =  0
           ...
        ELSEIF ( IOPT .EQ. 3 ) THEN
  C        Define names and types of signals
  C
  C        X: PHI1, PHI2, PHI1D, PHI2D
              CALL BLO3SX ('PHI1 ', 'Relative angle   of arm 1 in [rad]')
              CALL BLO3SX ('PHI2 ', 'Relative angle   of arm 2 in [rad]')
              CALL BLO3SX ('PHI1D', 'Angular velocity of arm 1 in [rad/s]')
              CALL BLO3SX ('PHI2D', 'Angular velocity of arm 2 in [rad/s]')
  C
  C        U: TORQUE(2)
              CALL BLO3TU ('TORQUE','Torque in the joints in [N]',1,2)
  C
  C        Y: RLOAD(3), ALOAD(3,3)
              CALL BLO3TY ('RLOAD','Position of load in [m]',1,3)
              CALL BLO3TY ('ALOAD','Direction cosine matrix of load',2,DIMA) 
           ...
        ENDIF 

  The signals are mapped in the following way to vectors:

        X ( 1): PHI1
          ( 2): PHI2
          ( 3): PHI1D
          ( 4): PHI2D
        U ( 1): TORQUE(1)
          ( 2): TORQUE(2)
        Y ( 1): RLOAD(1)
          ( 2): RLOAD(2) 
          ( 3): RLOAD(3)
          ( 4): ALOAD(1,1)
          ( 5): ALOAD(2,1)
          ( 6): ALOAD(3,1)
          ( 7): ALOAD(1,2)
          ...
          (12): ALOAD(3,3)
******
_utility_blo3ux__
SUBROUTINE
BLO3UX, Define the elements of the output equations which depend on U or XD
Procedure purpose:
  If models of DSblocks are connected, it is important to know, whether
  the output equations G(T,X,<XD>,U,P) depend explicitly on the input
  signals U or on the derivative of the state vector XD. See also "Example"
  below. If possible, this information should be given via subroutine BLO3UX.

  Furthermore, if the derivative XD of the state vector is needed in 
  subroutines BLOCKG or BLOCKK in case of ODE- or HDAE-models, this has to be
  explicitly requested by subroutine BLO3UX.
 
  It is only allowed to call this subroutine in subroutine BLOCKB, if IOPT=3.
                                                        
Usage:
  CALL BLO3UX (GU, GUI, GXD, KXD)

  GU    :  IN, INTEGER
           = 0 : G is not a function of U.
           = 1*: G is a function of U.
           = 2 : G is a function of some of the elements of U. The specific
                 elements of U are given by argument GUI
           (If BLO3UX is not called: GU=1)
  GUI   :  IN, OUT, INTEGER (*)
           If GU=2 then
              On entry  GUI(i)=1 for programming convenience
              On return GUI(i) = 0: G is NOT a function of U(i)
                               = 1: G is a function of U(i)
           else
              dummy argument (not used)
           endif
  GXD   :  IN, INTEGER
           If ODE or HDAE model then
              = 0*: XD is not needed by subroutine BLOCKG.
              = 1 : XD is needed by subroutine BLOCKG.
              (If BLO3UX is not called: GXD=0)
           else
              dummy argument
           endif
  KXD   :  IN, INTEGER
           If ODE or HDAE model then
              = 0*: XD is not needed by subroutine BLOCKK.
              = 1 : XD is needed by subroutine BLOCKK.
              (If BLO3UX is not called: KXD=1)
           else
              dummy argument
           endif
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  none
 
Remarks:
  none
 
Life cycle:
  1992 FEB  M. Otter, DLR FF-DF: specified
  1992 MAR  M. Otter, DLR FF-DF: modified
            GUI(i)=0/1 interchanged.
  1992 MAY  M. Otter, DLR FF-DF: modified
            Subroutine name changed from BLO3UG to BLO3UX.
            New arguments GXD, KXD.
 
Libraries required:
  depends on simulation environment
 
Example:
  In this example the reason is explained for providing subroutine BLO3UX.

  Two DSblocks 1 and 2 shall be connected via their input and output signals:

                       +-----------+
                 +---->| DSblock 1 |-----+
                 |     +-----------+     |
      u_1 = y_2  |                       | u_2 = y_1
                 |     +-----------+     |
                 +-----| DSblock 2 |<----+
                       +-----------+

  It is assumed, that both DSblocks are ODEs. The connection of the two
  DSblocks is actually done, by calling the corresponding DSblock subroutines 
  in a specific order. The following three main possibilities exist:

  1.) Connected DSblock is an ODE
      ---------------------------
      Under the assumptions, that output y_1 of DSblock 1 is no function of 
      input u_1 and neither output y_1 of DSblock 1 nor output y_2 of DSblock 2
      are functions of their state derivatives xd_1 and xd_2 respectively,
      the connected DSblock is an ODE:
     
      Independent variables     :  x_1(t),  x_2(t), t, p=const
      Variables to be calculated: xd_1(t), xd_2(t)

      Calling sequence          :   y_1 = g_1 (x_1, t, p)
                                    u_2 = y_1
                                    y_2 = g_2 (x_2, u_2, t, p)
                                    u_1 = y_2
                                   xd_1 = f_1 (x_1, u_1, t, p)
                                   xd_2 = f_2 (x_2, u_2, t, p)


  2.) Connected DSblock is a DAE with nx_1 + nx_2 equations
      -----------------------------------------------------
      Under the assumption, that output y_1 of DSblock 1 is no function of
      input u_1 the connected DSblock is a DAE:
     
      Independent variables     : x_1(t), x_2(t), xd_1(t), xd_2(t), t, p=const
      Variables to be calculated: residua res_1(t), res_2(t)

      Calling sequence          :   y_1 = g_1 (x_1, xd_1, t, p)
                                    u_2 = y_1
                                    y_2 = g_2 (x_2, xd_2, u_2, t, p)
                                    u_1 = y_2
                                  res_1 = f_1 (x_1, u_1, t, p) - xd_1
                                  res_2 = f_2 (x_2, u_2, t, p) - xd_2


  3.) Connected DSblock is a DAE with nx_1 + nx_2 + nu_1 equations
      ------------------------------------------------------------
      If no specific assumptions hold for the DSblocks, the connected DSblock
      is a DAE with either nx_1 + nx_2 + nu_1 or nx_1 + nx_2 + nu_2
      equations:

      Independent variables     : x_1(t), x_2(t), xd_1(t), xd_2(t), u_1(t), t, p
      Variables to be calculated: residua res_1(t), res_2(t), res3(t)

      Calling sequence          :   y_1 = g_1 (x_1, xd_1, u_1, t, p)
                                    u_2 = y_1
                                    y_2 = g_2 (x_2, xd_2, u_2, t, p)
                                  res_1 = f_1 (x_1, u_1, t, p) - xd_1
                                  res_2 = f_2 (x_2, u_2, t, p) - xd_2
                                  res_3 = u_1 - y_2
******
_utility_bloerl__
SUBROUTINE
BLOERL, Print error or warning message
Procedure purpose:
  An error or warning message is printed on the error output unit
  (= usually standard output).

  Dependent on the simulation environment, the text of the message is stored
  on a file or on a database. If accessible the text is read from file
  (database). Otherwise the short text given as argument TEXT is printed.

  The error or warning texts have to be stored in the following way:

    #1 <first row of message 1>
    <second row of message 1>
        ...
    <last row of message 1>
    #2 <first row of message 2>
    <second row of message 2>
        ... 
  
Usage:
  CALL BLOERL (NR, TEXT, TYPE, LIB)

  NR    :  IN, INTEGER
           Message number
  TEXT  :  IN, CHARACTER*(*)
           Short message text. TEXT is used as message text, if the
           error file (database) could not be opened or no text is present.
  TYPE  :  IN, INTEGER
           = 0: Warning (continue normal operation)
           = 1: Error (do not continue normal operation)
  LIB   :  IN, CHARACTER*(*)
           Name of file (text-object on database), in which the message is
           stored. Usually there exist a predefined directory (database
           structure) in which file (object) LIB is stored.
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  none
 
Remarks:
  none
 
Life cycle:
  1992 FEB  M. Otter, DLR FF-DF: specified
       Subroutine RSYERL of RSYST used as basis
 
Libraries required:
  depends on simulation environment
 
Example:
        CALL BLOERL (2,'Not possible to open model file',1,'MODELA')
******
_utility_bloers__
SUBROUTINE
BLOERS, Print error or warning message including run time values
Procedure purpose:
  An error or warning message is printed on the error output unit
  (= usually standard output). The message can contain the actual values of
  run time variables.

  Dependent on the simulation environment, the text of the message is stored
  on a file or on a database. If accessible the text is read from file
  (database). Otherwise the short text given as argument TEXT is printed.

  The error or warning texts have to be stored in the following way:

    #1 <first row of message 1>
    <second row of message 1>
        ...
    <last row of message 1>
    #2 <first row of message 2>
    <second row of message 2>
        ... 

  Run time variables are marked in the following way in the message:

    xxx <I1> yyy <R3> zzz
  
  Here xxx, yyy and zzz are any characters. <I1> means substitute 
  Integer value 1. <R3> means substitute Real value 3.
  
Usage:
  CALL BLOERS (NR,TEXT,TYPE,IW,RW,DW,CW,LI,LR,LD,LC,LIB)

  NR    :  IN, INTEGER
           Message number
  TEXT  :  IN, CHARACTER*(*)
           Short message text. TEXT is used as message text, if the
           error file (database) could not be opened or no text is present.
  TYPE  :  IN, INTEGER
           = 0: Warning (continue normal operation)
           = 1: Error (do not continue normal operation)
  IW    :  IN, INTEGER(*)
           Array with integer values to be substituted in the message.
  RW    :  IN, REAL(*)
           Array with real values to be substituted in the message.
  DW    :  IN, DOUBLE(*)  
           Array with double precision values to be substituted in the message.
  CW    :  IN, CHARACTER*(*) CW(*)
           Array with character values to be substituted in the message.
  LI    :  IN, INTEGER, LI >= 0
           Number of integer values
  LR    :  IN, INTEGER, LI >= 0
           Number of real values
  LD    :  IN, INTEGER, LI >= 0
           Number of double precision values
  LC    :  IN, INTEGER, LI >= 0
           Number of character values
  LIB   :  IN, CHARACTER*(*)
           Name of file (text-object on database), in which the message is
           stored. Usually there exist a predefined directory (database
           structure) in which file (object) LIB is stored.
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  none
 
Remarks:
  none
 
Life cycle:
  1992 FEB  M. Otter, DLR FF-DF: specified
       Subroutine RSYERS of RSYST used as basis
 
Libraries required:
  depends on simulation environment
 
Example:
     ...
        IW (1) = IMIN
        IW (2) = IVAL
        IW (3) = IMAX
        CALL BLOERS (4,'Parameter I out of range',1,IW,0.0,0.0D0,' ',
       +             3,0,0,0,'MODELA')
     ...

  The error text on file $DSBLOCK/MODELA may look like:

     ...
  #4 Parameter I (= <I2>) has to be in the range <I1> <= I <= <I3>.
     ...

  The message is printed in the following way, assuming that 
  IMIN=1, IVAL=7, IMAX=4:

  ***** Parameter I (= 7) has to be in the range 1 <= I <= 4.
******
_utility_blopri__
SUBROUTINE
BLOPRI, Write a text line on standard output
Procedure purpose:
  A text line is written on standard output.

Usage:
  CALL BLOPRI (TEXT)

  TEXT  :  IN, CHARACTER*(*)
           Line to be printed on standard output
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  none
 
Remarks:
  none
 
Life cycle:
  1992 FEB  M. Otter, DLR FF-DF: specified
 
Libraries required:
  depends on simulation environment
 
Example:
  none
******
_utility_blolu__
SUBROUTINE
BLOLUB/C Get/free logical unit number 
Procedure purpose:
  With subroutine BLOLUB free logical unit numbers can be inquired. These
  unit numbers can be used to access files in a DSblock.
  With subroutine BLOLUC a logical unit number inquired via BLOLUB can be
  returned back for use by other parts of the program.

  BLOLUB and BLOLUC are provided, because a DSblock is used in a simulation
  environment where several DSblocks are called: The simulation
  environment as well as different DSblocks are using logical unit numbers
  for file handling. The two subroutines guarantee that the same unit
  number is not used twice.

Usage:
  CALL BLOLUB (NLU,LU,IERR)

  NLU   :  IN, INTEGER
           Number of logical unit numbers to be required
  LU    :  OUT, INTEGER (NLU)
           Logical unit numbers which can be used in the DSblock.
  IERR  :  OUT, INTEGER
           =  0: No error occured
           else: Not enough unit numbers available.
                 No logical unit number given via LU(i)

  CALL BLOLUC (NLU,LU)

  NLU   :  IN, INTEGER
           Number of logical unit numbers to be returned back
  LU    :  IN, INTEGER (NLU)
           Logical unit numbers which are no longer used by the DSblock.
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  none
 
Remarks:
  none
 
Life cycle:
  1992 MAR  M. Otter, DLR FF-DF: specified
 
Libraries required:
  depends on simulation environment
 
Example:
  none
******
_utility_blosi__
SUBROUTINE
BLOSID/I, Inquire values, which have been set in the simulation environment
Procedure purpose:
  In the simulation environment values of several important variables
  are set. With subroutines BLOSID/BLOSII the actual values of some
  of these variables can be inquired.

Usage:
  CALL BLOSID (TYPE, DVAL, IERR)
  CALL BLOSII (TYPE, IVAL, IERR)
 
  TYPE  :  IN, INTEGER
           Type of variable to be inquired. Allowed values are:
           BLOSID:  TYPE = 1: Two time instants t1 and t2 are considered as
                              equal, if 'abs(t1 - t2) .le. min(t1,t2)*DVAL'
                              If, for example, a time event t1 and a
                              communication point t2 are identical within the
                              DVAL bound, the integration will be halted at
                              t2 and the time event will occur.
                         = 2: If delayed signals are present, signals are
                              only stored in a delay buffer at time t1, if
                              t1 > t2+DVAL, where t2 is the time instant
                              of the previously stored signal.
                         = 3: Final simulation time. 
                         = 4: EPS for event handling
           BLOSII:  TYPE = 1: IVAL=2: Results are stored in REAL precision.
                                  =3: Results are stored in DOUBLE precision. 
                         = 2: Priority of debug output in model
                              (default priority=0 means no output;
                              = PrintEvent for Dymola).
                         = 3: Maximum number of iterations at an event instant.
                              (= MaxIter)
  DVAL  :  OUT, DOUBLE
           Double precision value, according to TYPE.
  IVAL  :  OUT, INTEGER
           Integer value, according to TYPE.
  IERR  :  OUT, INTEGER
           Error parameter
           =  0: No error occured.
           else: TYPE has no valid value, or TYPE is not supported.
 
Database structure:
  none
 
File input/output:
  none
 
Dialog:
  none
 
Method:
  none
 
Remarks:
  none
 
Life cycle:
  1992 FEB  M. Otter, DLR FF-DF: specified
  1992 MAR  M. Otter, DLR FF-DF: modified
            Type of variable via Integer and not via Character argument
  1992 MAY  M. Otter, DLR FF-DF: modified
            New TYPE=3 for BLOSID
  1994 APR  M. Otter, DLR FF-DF: modified
            New TYPE=4   for BLOSID
            New TYPE=2,3 for BLOSII
 
Libraries required:
  depends on simulation environment
 
Example:
        INTEGER    PEPS  , PPREC
        PARAMETER (PEPS=1, PPREC=1)
           ...
        CALL BLOSID (PEPS , teps)
        CALL BLOSII (PPREC,iprec)
******

